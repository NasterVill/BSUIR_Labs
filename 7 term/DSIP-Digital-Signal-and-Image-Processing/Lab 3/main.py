import numpy as np

import utils
from HopfieldNetwork import HopfieldNetwork


def process_shape(initial_shape: np.ndarray, net: HopfieldNetwork):
    noised_shapes = []

    for i in range(5, 105, 5):
        noise_level = i / 100

        noised_shapes.append(utils.noise_shape(initial_shape, noise_level))

    for i in range(len(noised_shapes)):
        recognized, adjusted_shape, iterations = net.recognize(noised_shapes[i])

        print('Noise %:', '%.2f' % ((i + 1) * 0.05))
        print('Amount of iterations:', iterations)
        print('Is image recognized:', recognized)
        print(adjusted_shape)

        print('\n\n')


def main():
    first_shape = np.array([
        [1, 1, 0, 0, 0, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 0, 0, 1, 1, 1],
        [0, 1, 1, 0, 0, 0, 1, 1, 0, 0],
        [0, 0, 1, 1, 0, 1, 1, 0, 0, 0],
        [0, 0, 0, 1, 1, 1, 0, 0, 0, 0],
        [0, 0, 0, 1, 1, 0, 0, 0, 0, 0],
        [0, 0, 1, 1, 0, 0, 0, 0, 0, 0],
        [0, 1, 1, 0, 0, 0, 0, 0, 0, 0],
        [1, 1, 0, 0, 0, 0, 0, 0, 0, 0],
        [1, 1, 0, 0, 0, 0, 0, 0, 0, 0],
    ])

    second_shape = np.array([
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
        [1, 1, 0, 0, 0, 0, 0, 0, 0, 0],
        [1, 1, 0, 0, 0, 0, 0, 0, 0, 0],
        [1, 1, 0, 0, 0, 0, 0, 0, 0, 0],
        [1, 1, 0, 0, 0, 0, 0, 0, 0, 0],
        [1, 1, 0, 0, 0, 0, 0, 0, 0, 0],
        [1, 1, 0, 0, 0, 0, 0, 0, 0, 0],
        [1, 1, 0, 0, 0, 0, 0, 0, 0, 0],
        [1, 1, 0, 0, 0, 0, 0, 0, 0, 0],
    ])

    third_shape = np.array([
        [1, 1, 0, 0, 0, 0, 0, 0, 1, 1],
        [1, 1, 1, 0, 0, 0, 0, 1, 1, 1],
        [1, 1, 1, 1, 0, 0, 1, 1, 1, 1],
        [1, 1, 0, 1, 1, 1, 1, 0, 1, 1],
        [1, 1, 0, 0, 1, 1, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 0, 0, 0, 1, 1],
    ])

    # transform shapes to 1 / -1 values
    first_shape = utils.normalize(first_shape)
    second_shape = utils.normalize(second_shape)
    third_shape = utils.normalize(third_shape)

    dimension = 10

    # create network instance
    net = HopfieldNetwork(dimension)

    # teaching the net
    net.teach(first_shape)
    net.teach(second_shape)
    net.teach(third_shape)

    # recreating shapes with noise
    process_shape(first_shape, net)
    process_shape(second_shape, net)
    process_shape(third_shape, net)


if __name__ == '__main__':
    main()

